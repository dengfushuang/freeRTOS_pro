/****************************************Copyright (c)**************************************************
**                               广州周立功单片机发展有限公司
**                                     研    究    所
**                                        产品一部
**
**                                 http://www.zlgmcu.com
**
**--------------文件信息--------------------------------------------------------------------------------
**文   件   名: uart0.c
**创   建   人: 陈明计
**最后修改日期: 2003年7月4日
**描        述: μCOS-II下LPC210x的UART0底层驱动
**
**--------------历史版本信息----------------------------------------------------------------------------
** 创建人: 陈明计
** 版  本: v1.0
** 日　期: 2003年7月4日
** 描　述: 原始版本
**
**------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 版  本: v1.1
** 日　期: 2003年7月21日
** 描　述: 根据正式文档更改寄存器名
**
**--------------当前版本修订------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2004年4月30日
** 描　述: 修改数据队列空间的分配，保证其为4字节对齐
**
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/

//#define IN_UART0
#include  "user_config.h"
#include  "uart0.h"
#include  "user_queue.h"
static int UART0SendBuf[(UART0_SEND_QUEUE_LENGTH + sizeof(int) - 1) / sizeof(int)];

static SemaphoreHandle_t *Uart0Sem;

/*********************************************************************************************************
** 函数名称: Uart0WriteFull
** 功能描述: 数据队列写满处理程序
** 输　入: Buf:指向数据队列
**        Data:将要入队的数据
**        Mod: 入队方式
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
    uint8_t Uart0WriteFull(DataQueue *Buf, QUEUE_DATA_TYPE Data, uint8_t Mod)
{
    uint16_t temp;

    Mod = Mod;

    temp = QueueSize((void *)Buf);
    while (temp <= QueueNData((void *)Buf))         /* 等待数据队列不满 */
    {
        vTaskDelay(2*5);
    }
    return QueueWrite((void *)Buf, Data);           /* 数据重新入队 */
}

/*********************************************************************************************************
** 函数名称: UART0Init
** 功能描述: 初始化UART0
** 输　入: bps：波特率
**
** 输　出:TRUE  :成功
**        FALSE:失败
** 全局变量: Uart0Sem
** 调用模块: QueueCreate,OSSemCreate
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月8日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月21日
**------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2004年4月30日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
extern uint32_t SystemCoreClock;
uint8_t  UART0Init(uint8_t BPS)
{
    uint16_t Fdiv;
    uint32_t bps; 
    //使能以UART0控制器电源    
    LPC_SC->PCONP |= (1<<3);
    // Enable P0 Ethernet Pins.
    LPC_IOCON->P0_2 = 0x01;     //ENET_U0_TXD
    LPC_IOCON->P0_3 = 0x01;     //ENET_U0_RXD
	
    switch ( BPS )
    {
        case 1 :
             bps = 2400;
            break;
        case 2 :
             bps = 4800;
            break;
        case 3 :
             bps = 9600;
            break;
        case 4 :
             bps = 14400;
            break;
        case 5 :
             bps = 19200;
            break;
        case 6 :
             bps = 38400;
            break;
        case 7 :
             bps = 56000;
            break;
        case 8 :
             bps = 57600;
            break;
         case 9 :
             bps = 115200;
            break;               
        default:  break;
    }
    LPC_UART0->LCR = 0x80;                      // 允许访问分频因子寄存器     
    Fdiv = (PeripheralClock / 16) / bps ;       // 设置波特率 
    LPC_UART0->DLM = Fdiv / 256;
	LPC_UART0->DLL = Fdiv % 256;
    LPC_UART0->LCR = 0x03;                      // 禁止访问分频因子寄存器 
                                                // 且设置为8,1,n 
	LPC_UART0->IER = 0x05;                      // 允许接收和发送中断 
    LPC_UART0->FCR = 0x87;                      // 初始化FIFO 

    NVIC_EnableIRQ(UART0_IRQn);                 // Enable UART0 interrupt 
    
    if (QueueCreate((void *)UART0SendBuf,
                     sizeof(UART0SendBuf),
                     NULL,
                     (uint8_t (*)())Uart0WriteFull) 
                     == NOT_OK)
    {
        return FALSE;
    }
    Uart0Sem = xSemaphoreCreateBinary();
    return TRUE;

}

/*********************************************************************************************************
** 函数名称: UART0Putch
** 功能描述: 发送一个字节数据
** 输　入: Data：发送的数据数据
** 输　出:无
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月8日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月21日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0Putch(uint8_t Data)
{
    uint8_t temp;
    QueueWrite((void *)UART0SendBuf, Data);         /* 数据入队 */
    portENTER_CRITICAL();
    if ((LPC_UART0->LSR & 0x00000020) != 0)
    {                                               /* UART0发送保持寄存器空 */
        QueueRead(&temp, UART0SendBuf);             /* 发送最初入队的数据 */
        LPC_UART0->THR = temp;
        LPC_UART0->IER = LPC_UART0->IER | 0x02;     /* 允许发送中断 */
    }
    portEXIT_CRITICAL();
}

/*********************************************************************************************************
** 函数名称: UART0Write
** 功能描述: 发送多个字节数据
** 输　入: Data:发送数据存储位置
**        NByte:发送数据个数
** 输　出:无
** 全局变量: 无
** 调用模块: UART0Putch
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月8日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
 void UART0Put_str(uint8_t *Data, uint16_t NByte)
{
    //OS_ENTER_CRITICAL(;
    while (NByte-- > 0)
    {
        UART0Putch(*Data++);
    }
    //OS_EXIT_CRITICAL(;
}

void UART0Write_Str(uint8_t *Data)
{
    //OS_ENTER_CRITICAL(;
    while (*Data != '\0' )
    {
        UART0Putch(*Data++);
    }
    //OS_EXIT_CRITICAL(;
}
/*********************************************************************************************************
** 函数名称: UART0Getch
** 功能描述: 接收一个字节
** 输　入: 无
** 输　出: 接收到的数据
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月8日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月21日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8_t UART0Getch(void)
{
    uint8_t err;
	//OS_CPU_SR  cpu_sr;
	
    //OS_ENTER_CRITICAL(;
    while ((LPC_UART0->LSR & 0x00000001) == 0)
    {                                           /* 没有收到数据 */
        LPC_UART0->IER = LPC_UART0->IER | 0x01; /* 允许接收中断 */
        xSemaphoreTake(Uart0Sem,1);           /* 等待接收数据 */
		LPC_UART0->IER = LPC_UART0->IER | 0x01; /* 允许接收中断 */
    }
    err = LPC_UART0->RBR;                       /* 读取收到的数据 */
    //OS_EXIT_CRITICAL(;
    return err;
}

/*********************************************************************************************************
** 函数名称: UART0_Exception
** 功能描述: UART0中断服务程序
** 输　入: 无
**
** 输　出: 无
**
** 全局变量: 无
** 调用模块: QueueRead,OSSemPost
**
** 作　者: 陈明计
** 日　期: 2003年7月4日
**-------------------------------------------------------------------------------------------------------
** 修改人: 陈明计
** 日　期: 2003年7月21日
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0_IRQHandler (void) 
{
    uint8_t IIR, temp, i;
	static BaseType_t xHigherPriorityTaskWoken;
    portENTER_CRITICAL();

    while(((IIR = LPC_UART0->IIR) & 0x01) == 0)
    {                                                   /* 有中断未处理完 */
        switch (IIR & 0x0e)
        {
            case 0x02:                                  /* THRE中断    */
                for (i = 0; i < UART0_FIFO_LENGTH; i++) /* 向发送FIFO填充数据 */
                {
                    if (QueueRead(&temp, UART0SendBuf) == QUEUE_OK)
                    {
                        LPC_UART0->THR = temp;
                    }
                    else
                    {
                        LPC_UART0->IER = LPC_UART0->IER & (~0x02);        /* 队列空，则禁止发送中断 */
                    }
                }
                break;
            case 0x04:                                  /* 接收数据可用 */
                xSemaphoreGiveFromISR( Uart0Sem, &xHigherPriorityTaskWoken );                    /* 通知接收任务 */
                LPC_UART0->IER = LPC_UART0->IER & (~0x01);                /* 禁止接收及字符超时中断 */
                break;
            case 0x06:                                  /* 接收线状态   */
                temp = LPC_UART0->LSR;
                break;
            case 0x0c:                                  /* 字符超时指示 */
                xSemaphoreGiveFromISR( Uart0Sem, &xHigherPriorityTaskWoken );                   /* 通知接收任务 */
                LPC_UART0->IER = LPC_UART0->IER & (~0x01);                /* 禁止接收及字符超时中断 */
                break;
            default :
            	temp = LPC_UART0->LSR;
                break;
        }
    }
    //VICVectAddr = 0;            // 通知中断控制器中断结束
    portEXIT_CRITICAL();
}

/*********************************************************************************************************
**                            End Of File
********************************************************************************************************/
